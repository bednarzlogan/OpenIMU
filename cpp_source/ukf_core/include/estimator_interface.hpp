#pragma once

#include <Eigen/Dense>
#include <filesystem>
#include <stdexcept>
#include <string>

/// NOTE: though this specifies UKF, many of its types are general to other
/// estimators
#include "ukf_defs.hpp"

using std::string;
namespace fs = std::filesystem;

inline string get_ground_truth(const string &path_to_measurements) {
  // the files generated by the simulator have a matching ground truth file
  // that's associated by a shared timestamp

  // extract parent directory
  fs::path parent_dir = fs::path(path_to_measurements).parent_path();

  // extract timestamp suffix from filename
  size_t found = path_to_measurements.find("test_");
  if (found == string::npos) {
    throw std::runtime_error(
        "Expected 'test_' in filename but did not find it.");
  }

  size_t suffix_start = found + 5; // skip past 'test_'
  string date_string = path_to_measurements.substr(suffix_start);

  // check all files in that dir for the pattern
  for (const auto &entry : fs::directory_iterator(parent_dir)) {
    string candidate = entry.path().filename().string();
    if (candidate.find("ground_truth_") != string::npos &&
        candidate.find(date_string) != string::npos) {
      return (parent_dir / candidate).string();
    }
  }

  throw std::runtime_error("No matching ground truth file found for: " +
                           path_to_measurements);
}

class Estimator {
public:
  virtual ~Estimator() = default; // virtual destructor for polymorphism

  // initialize the filter
  virtual void initialize(const StateVec &initial_state,
                          const CovMat &initial_covariance) = 0;

  // wake filter
  virtual void start_filter(std::chrono::milliseconds period) = 0;
  virtual void stop_filter() = 0;

  // kickoff for sim mode processing
  virtual void read_imu(ImuData imu_measurement) = 0;
  virtual void read_gps(Observable observable_measurement) = 0;

  // predict step (for IMU propagation, etc.)
  virtual void predict(const ControlInput &u, double dt) = 0;

  // update step (for correcting with measurements)
  virtual void update(const MeasVec &z, const MeasCov &R) = 0;

  // get current estimate
  virtual const StateVec &get_state() const = 0;

  // get current covariance
  virtual const CovMat &get_covariance() const = 0;

  // virtual getter for dropped measurement count
  virtual size_t get_dropped_measurement_count(bool imu) const noexcept = 0;

  // virtual getter for queues full status
  virtual bool queues_full(bool imu) const noexcept = 0;

  // virtual getter for queues empty status
  virtual bool queues_empty(bool imu) const noexcept = 0;

  // virtual getter for solution time
  virtual double solution_time() const noexcept = 0;
};
