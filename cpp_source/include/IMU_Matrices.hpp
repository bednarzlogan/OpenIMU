// Auto-generated by export_matrices_to_hpp.py
#ifndef GENERATED_MATRICES_HPP
#define GENERATED_MATRICES_HPP

#include <array>
#include <iostream>
#include <Eigen/Dense>

// struct for setting up IMU dynamics based on an external file read
struct Config {
    double sig_ax, sig_ay, sig_az; // accel variances
    double sig_gx, sig_gy, sig_gz; // gyro variances
    double sig_tax, sig_tay, sig_taz; // accel FOGMP noise
    double sig_tgx, sig_tgy, sig_tgz; // gyro FOGMP noise
    double tau_gx, tau_gy, tau_gz; // gyro bias time constants
    double tau_ax, tau_ay, tau_az; // accel bias time constants
    double Ts; // update interval
};

// measurements and expected state vector definitions
struct ImuData {
    double accx, accy, accz;
    double dphix, dthetay, dpsiz;
    double measurement_time;
    Eigen::Matrix<double,6,1> matrix_form_measurement;

    void updateFromMatrix() {
        accx    = matrix_form_measurement(0); accy    = matrix_form_measurement(1); accz    = matrix_form_measurement(2);
        dphix   = matrix_form_measurement(3); dthetay = matrix_form_measurement(4); dpsiz   = matrix_form_measurement(5);
    }

    void updateFromDoubles() {
        matrix_form_measurement(0)=accx; matrix_form_measurement(1)=accy; matrix_form_measurement(2)=accz;
        matrix_form_measurement(3)=dphix; matrix_form_measurement(4)=dthetay; matrix_form_measurement(5)=dpsiz;
    }
};

struct ImuStateVector {
    double pos_x,pos_y,pos_z; double vel_x,vel_y,vel_z;
    double phi,theta,psi; double bias_x,bias_y,bias_z;
    double bias_phi,bias_theta,bias_psi;
    double solution_time;
    Eigen::Matrix<double,15,1> matrix_form_states;

    void updateFromMatrix() {
        pos_x=matrix_form_states(0); pos_y=matrix_form_states(1); pos_z=matrix_form_states(2);
        vel_x=matrix_form_states(3); vel_y=matrix_form_states(4); vel_z=matrix_form_states(5);
        phi  =matrix_form_states(6); theta=matrix_form_states(7); psi  =matrix_form_states(8);
        bias_x=matrix_form_states(9); bias_y=matrix_form_states(10); bias_z=matrix_form_states(11);
        bias_phi=matrix_form_states(12); bias_theta=matrix_form_states(13); bias_psi=matrix_form_states(14);
    }
};

struct ImuCovariance {
    double solution_time;
    Eigen::Matrix<double,15,15> covariance_matrix;
};

class GeneratedMatrices {
public:
    // define the expectation for how many fields will be in an IMU meausrement
    // and how many states are in the state-space model
    static const uint8_t NUM_STATES_IMU = 15;
    static const uint8_t NUM_IMU_MEASUREMENTS = 6;

	std::array<Eigen::MatrixXd,3> eval_generated_system() {
		std::array<Eigen::MatrixXd,3> ret_sys;

		// Trig shorthands
		double sin_theta = sin(theta);
		double cos_theta = cos(theta);
		double tan_theta = tan(theta);
		double sin_phi = sin(phi);
		double cos_phi = cos(phi);

		// common sub-expression from sympy
		double x0 = cos(psi);
		double x1 = 0.5*pow(Ts, 2);
		double x2 = cos_theta*x1;
		double x3 = sin(psi);
		double x4 = cos_phi*x3;
		double x5 = sin_phi*x0;
		double x6 = -sin_theta*x5 + x4;
		double x7 = sin_phi*x3;
		double x8 = cos_phi*x0;
		double x9 = sin_theta*x8 + x7;
		double x10 = pow(cos_theta, 2);
		double x11 = sig_ax*x10;
		double x12 = sig_ay*pow(x6, 2) + sig_az*pow(x9, 2) + pow(x0, 2)*x11;
		double x13 = sin_theta*x4 - x5;
		double x14 = sig_az*x9;
		double x15 = sin_theta*x7 + x8;
		double x16 = -sig_ay*x15*x6 + x0*x11*x3 + x13*x14;
		double x17 = -x16;
		double x18 = -cos_phi*x14 + sig_ax*sin_theta*x0 + sig_ay*sin_phi*x6;
		double x19 = cos_theta*x18;
		double x20 = sig_ay*pow(x15, 2) + sig_az*pow(x13, 2) + x11*pow(x3, 2);
		double x21 = cos_phi*sig_az*x13 - sig_ax*sin_theta*x3 + sig_ay*sin_phi*x15;
		double x22 = -cos_theta*x21;
		double x23 = cos_theta*sin_phi;
		double x24 = cos_phi*cos_theta;
		double x25 = pow(cos_phi, 2);
		double x26 = pow(sin_phi, 2);
		double x27 = sig_ax*pow(sin_theta, 2) + sig_ay*x10*x26 + sig_az*x10*x25;
		double x28 = -fbx*sin_theta + fby*x23 + fbz*x24;
		double x29 = Ts*x28;
		double x30 = cos_theta*fbx;
		double x31 = fby*x15 + fbz*x13 + x3*x30;
		double x32 = Ts*x31;
		double x33 = Ts*cos_theta;
		double x34 = x0*x33;
		double x35 = Ts*x6;
		double x36 = Ts*x9;
		double x37 = cos_phi*x28;
		double x38 = (1.0/cos(theta));
		double x39 = x31*x38;
		double x40 = -cos_theta*x18;
		double x41 = sig_gy - sig_gz;
		double x42 = sig_gz*x25;
		double x43 = sig_gy*x26;
		double x44 = x42 + x43;
		double x45 = sin_phi*x37*x41 - x39*x44;
		double x46 = sig_gy*x25 + sig_gz*x26;
		double x47 = cos_phi*x41;
		double x48 = fbz*x9 + x0*x30;
		double x49 = -fby*x6 + x48;
		double x50 = Ts*x49;
		double x51 = x3*x33;
		double x52 = Ts*x15;
		double x53 = Ts*x13;
		double x54 = x38*x49;
		double x55 = tan_theta*x28 - x54;
		double x56 = x1*x55;
		double x57 = cos_theta*x21;
		double x58 = pow(tan_theta, 2);
		double x59 = sig_gx + x42*x58 + x43*x58;
		double x60 = tan_theta*x44;
		double x61 = -x55;
		double x62 = cos_phi*sin_phi;
		double x63 = x41*x62;
		double x64 = Ts*sin_theta;
		double x65 = Ts*sin_phi;
		double x66 = cos_theta*x65;
		double x67 = Ts*cos_phi;
		double x68 = cos_theta*x67;
		double x69 = tan_theta*x31;
		double x70 = sin_phi*x69;
		double x71 = -fby*x6 + x48;
		double x72 = x63*x71;
		double x73 = cos_phi*theta_dot;
		double x74 = psi_dot*sin_phi;
		double x75 = x73 - x74;
		double x76 = Ts*x75;
		double x77 = tan_theta*x76;
		double x78 = pow(x38, 2);
		double x79 = cos_phi*psi_dot + sin_phi*theta_dot;
		double x80 = Ts*x79;
		double x81 = x78*x80;
		double x82 = tan_theta*x65;
		double x83 = tan_theta*x67;
		double x84 = 0.5*x77 + 1;
		double x85 = 0.5*x81;
		double x86 = tan_theta*x63;
		double x87 = x79*x86;
		double x88 = -tan_theta*x73 + tan_theta*x74 + 1;
		double x89 = x46*x79;
		double x90 = x63*x79;
		double x91 = sig_tax + sig_tgx;
		double x92 = sig_tay + sig_tgy;
		double x93 = sin_phi*x92;
		double x94 = sig_taz + sig_tgz;
		double x95 = cos_phi*x94;
		double x96 = tan_theta*x80;
		double x97 = 0.5*x96;
		double x98 = sin_phi*x97;
		double x99 = cos_phi*x97 + sin_phi;
		double x100 = sig_gy*x62;
		double x101 = sig_gz*x62;
		double x102 = 0.5*x75;
		double x103 = Ts*x38;
		double x104 = 1.0/tau_gx;
		double x105 = 1.0/tau_gy;
		double x106 = 1.0/tau_gz;

		// discrete time IMU state transition matrix
		Eigen::Matrix<double,15,15> phi_k;
		phi_k(0,0) = 1;
		phi_k(0,1) = 0;
		phi_k(0,2) = 0;
		phi_k(0,3) = Ts;
		phi_k(0,4) = 0;
		phi_k(0,5) = 0;
		phi_k(0,6) = 0;
		phi_k(0,7) = 0;
		phi_k(0,8) = 0;
		phi_k(0,9) = 0;
		phi_k(0,10) = 0;
		phi_k(0,11) = 0;
		phi_k(0,12) = 0;
		phi_k(0,13) = 0;
		phi_k(0,14) = 0;
		phi_k(1,0) = 0;
		phi_k(1,1) = 1;
		phi_k(1,2) = 0;
		phi_k(1,3) = 0;
		phi_k(1,4) = Ts;
		phi_k(1,5) = 0;
		phi_k(1,6) = 0;
		phi_k(1,7) = 0;
		phi_k(1,8) = 0;
		phi_k(1,9) = 0;
		phi_k(1,10) = 0;
		phi_k(1,11) = 0;
		phi_k(1,12) = 0;
		phi_k(1,13) = 0;
		phi_k(1,14) = 0;
		phi_k(2,0) = 0;
		phi_k(2,1) = 0;
		phi_k(2,2) = 1;
		phi_k(2,3) = 0;
		phi_k(2,4) = 0;
		phi_k(2,5) = Ts;
		phi_k(2,6) = 0;
		phi_k(2,7) = 0;
		phi_k(2,8) = 0;
		phi_k(2,9) = 0;
		phi_k(2,10) = 0;
		phi_k(2,11) = 0;
		phi_k(2,12) = 0;
		phi_k(2,13) = 0;
		phi_k(2,14) = 0;
		phi_k(3,0) = 0;
		phi_k(3,1) = 0;
		phi_k(3,2) = 0;
		phi_k(3,3) = 1;
		phi_k(3,4) = 0;
		phi_k(3,5) = 0;
		phi_k(3,6) = 0;
		phi_k(3,7) = -x29;
		phi_k(3,8) = x32;
		phi_k(3,9) = -x34;
		phi_k(3,10) = x35;
		phi_k(3,11) = -x36;
		phi_k(3,12) = 0;
		phi_k(3,13) = 0;
		phi_k(3,14) = 0;
		phi_k(4,0) = 0;
		phi_k(4,1) = 0;
		phi_k(4,2) = 0;
		phi_k(4,3) = 0;
		phi_k(4,4) = 1;
		phi_k(4,5) = 0;
		phi_k(4,6) = x29;
		phi_k(4,7) = 0;
		phi_k(4,8) = -x50;
		phi_k(4,9) = -x51;
		phi_k(4,10) = -x52;
		phi_k(4,11) = -x53;
		phi_k(4,12) = 0;
		phi_k(4,13) = 0;
		phi_k(4,14) = 0;
		phi_k(5,0) = 0;
		phi_k(5,1) = 0;
		phi_k(5,2) = 0;
		phi_k(5,3) = 0;
		phi_k(5,4) = 0;
		phi_k(5,5) = 1;
		phi_k(5,6) = -x32;
		phi_k(5,7) = x50;
		phi_k(5,8) = 0;
		phi_k(5,9) = x64;
		phi_k(5,10) = -x66;
		phi_k(5,11) = -x68;
		phi_k(5,12) = 0;
		phi_k(5,13) = 0;
		phi_k(5,14) = 0;
		phi_k(6,0) = 0;
		phi_k(6,1) = 0;
		phi_k(6,2) = 0;
		phi_k(6,3) = 0;
		phi_k(6,4) = 0;
		phi_k(6,5) = 0;
		phi_k(6,6) = x77 + 1;
		phi_k(6,7) = x81;
		phi_k(6,8) = 0;
		phi_k(6,9) = 0;
		phi_k(6,10) = 0;
		phi_k(6,11) = 0;
		phi_k(6,12) = -Ts;
		phi_k(6,13) = -x82;
		phi_k(6,14) = -x83;
		phi_k(7,0) = 0;
		phi_k(7,1) = 0;
		phi_k(7,2) = 0;
		phi_k(7,3) = 0;
		phi_k(7,4) = 0;
		phi_k(7,5) = 0;
		phi_k(7,6) = -x80;
		phi_k(7,7) = 1;
		phi_k(7,8) = 0;
		phi_k(7,9) = 0;
		phi_k(7,10) = 0;
		phi_k(7,11) = 0;
		phi_k(7,12) = 0;
		phi_k(7,13) = -x67;
		phi_k(7,14) = x65;
		phi_k(8,0) = 0;
		phi_k(8,1) = 0;
		phi_k(8,2) = 0;
		phi_k(8,3) = 0;
		phi_k(8,4) = 0;
		phi_k(8,5) = 0;
		phi_k(8,6) = x38*x76;
		phi_k(8,7) = x38*x96;
		phi_k(8,8) = 1;
		phi_k(8,9) = 0;
		phi_k(8,10) = 0;
		phi_k(8,11) = 0;
		phi_k(8,12) = 0;
		phi_k(8,13) = -x38*x65;
		phi_k(8,14) = -x38*x67;
		phi_k(9,0) = 0;
		phi_k(9,1) = 0;
		phi_k(9,2) = 0;
		phi_k(9,3) = 0;
		phi_k(9,4) = 0;
		phi_k(9,5) = 0;
		phi_k(9,6) = 0;
		phi_k(9,7) = 0;
		phi_k(9,8) = 0;
		phi_k(9,9) = -Ts/tau_ax + 1;
		phi_k(9,10) = 0;
		phi_k(9,11) = 0;
		phi_k(9,12) = 0;
		phi_k(9,13) = 0;
		phi_k(9,14) = 0;
		phi_k(10,0) = 0;
		phi_k(10,1) = 0;
		phi_k(10,2) = 0;
		phi_k(10,3) = 0;
		phi_k(10,4) = 0;
		phi_k(10,5) = 0;
		phi_k(10,6) = 0;
		phi_k(10,7) = 0;
		phi_k(10,8) = 0;
		phi_k(10,9) = 0;
		phi_k(10,10) = -Ts/tau_ay + 1;
		phi_k(10,11) = 0;
		phi_k(10,12) = 0;
		phi_k(10,13) = 0;
		phi_k(10,14) = 0;
		phi_k(11,0) = 0;
		phi_k(11,1) = 0;
		phi_k(11,2) = 0;
		phi_k(11,3) = 0;
		phi_k(11,4) = 0;
		phi_k(11,5) = 0;
		phi_k(11,6) = 0;
		phi_k(11,7) = 0;
		phi_k(11,8) = 0;
		phi_k(11,9) = 0;
		phi_k(11,10) = 0;
		phi_k(11,11) = -Ts/tau_az + 1;
		phi_k(11,12) = 0;
		phi_k(11,13) = 0;
		phi_k(11,14) = 0;
		phi_k(12,0) = 0;
		phi_k(12,1) = 0;
		phi_k(12,2) = 0;
		phi_k(12,3) = 0;
		phi_k(12,4) = 0;
		phi_k(12,5) = 0;
		phi_k(12,6) = 0;
		phi_k(12,7) = 0;
		phi_k(12,8) = 0;
		phi_k(12,9) = 0;
		phi_k(12,10) = 0;
		phi_k(12,11) = 0;
		phi_k(12,12) = -Ts*x104 + 1;
		phi_k(12,13) = 0;
		phi_k(12,14) = 0;
		phi_k(13,0) = 0;
		phi_k(13,1) = 0;
		phi_k(13,2) = 0;
		phi_k(13,3) = 0;
		phi_k(13,4) = 0;
		phi_k(13,5) = 0;
		phi_k(13,6) = 0;
		phi_k(13,7) = 0;
		phi_k(13,8) = 0;
		phi_k(13,9) = 0;
		phi_k(13,10) = 0;
		phi_k(13,11) = 0;
		phi_k(13,12) = 0;
		phi_k(13,13) = -Ts*x105 + 1;
		phi_k(13,14) = 0;
		phi_k(14,0) = 0;
		phi_k(14,1) = 0;
		phi_k(14,2) = 0;
		phi_k(14,3) = 0;
		phi_k(14,4) = 0;
		phi_k(14,5) = 0;
		phi_k(14,6) = 0;
		phi_k(14,7) = 0;
		phi_k(14,8) = 0;
		phi_k(14,9) = 0;
		phi_k(14,10) = 0;
		phi_k(14,11) = 0;
		phi_k(14,12) = 0;
		phi_k(14,13) = 0;
		phi_k(14,14) = -Ts*x106 + 1;
		ret_sys[0] = phi_k;

		// matrix which projects IMU accelerometer/gyro readouts onto state
		Eigen::Matrix<double,15,6> gamma_uk;
		gamma_uk(0,0) = x0*x2;
		gamma_uk(0,1) = -x1*x6;
		gamma_uk(0,2) = x1*x9;
		gamma_uk(0,3) = 0;
		gamma_uk(0,4) = 0;
		gamma_uk(0,5) = 0;
		gamma_uk(1,0) = x2*x3;
		gamma_uk(1,1) = x1*x15;
		gamma_uk(1,2) = x1*x13;
		gamma_uk(1,3) = 0;
		gamma_uk(1,4) = 0;
		gamma_uk(1,5) = 0;
		gamma_uk(2,0) = -sin_theta*x1;
		gamma_uk(2,1) = x1*x23;
		gamma_uk(2,2) = x1*x24;
		gamma_uk(2,3) = 0;
		gamma_uk(2,4) = 0;
		gamma_uk(2,5) = 0;
		gamma_uk(3,0) = x34;
		gamma_uk(3,1) = -x35;
		gamma_uk(3,2) = x36;
		gamma_uk(3,3) = 0;
		gamma_uk(3,4) = x1*(sin_phi*x31*x38 - x37);
		gamma_uk(3,5) = x1*(cos_phi*x39 + sin_phi*x28);
		gamma_uk(4,0) = x51;
		gamma_uk(4,1) = x52;
		gamma_uk(4,2) = x53;
		gamma_uk(4,3) = x1*x28;
		gamma_uk(4,4) = sin_phi*x56;
		gamma_uk(4,5) = cos_phi*x56;
		gamma_uk(5,0) = -x64;
		gamma_uk(5,1) = x66;
		gamma_uk(5,2) = x68;
		gamma_uk(5,3) = -x1*x31;
		gamma_uk(5,4) = x1*(cos_phi*x49 - x70);
		gamma_uk(5,5) = -x1*(cos_phi*x69 + sin_phi*x49);
		gamma_uk(6,0) = 0;
		gamma_uk(6,1) = 0;
		gamma_uk(6,2) = 0;
		gamma_uk(6,3) = Ts*x84;
		gamma_uk(6,4) = Ts*(cos_phi*x85 + sin_phi*tan_theta*x84);
		gamma_uk(6,5) = Ts*(cos_phi*tan_theta*x84 - sin_phi*x85);
		gamma_uk(7,0) = 0;
		gamma_uk(7,1) = 0;
		gamma_uk(7,2) = 0;
		gamma_uk(7,3) = -x1*x79;
		gamma_uk(7,4) = Ts*(cos_phi - x98);
		gamma_uk(7,5) = -Ts*x99;
		gamma_uk(8,0) = 0;
		gamma_uk(8,1) = 0;
		gamma_uk(8,2) = 0;
		gamma_uk(8,3) = x1*x38*x75;
		gamma_uk(8,4) = x103*(x102*x82 + x99);
		gamma_uk(8,5) = x103*(cos_phi + x102*x83 - x98);
		gamma_uk(9,0) = 0;
		gamma_uk(9,1) = 0;
		gamma_uk(9,2) = 0;
		gamma_uk(9,3) = 0;
		gamma_uk(9,4) = 0;
		gamma_uk(9,5) = 0;
		gamma_uk(10,0) = 0;
		gamma_uk(10,1) = 0;
		gamma_uk(10,2) = 0;
		gamma_uk(10,3) = 0;
		gamma_uk(10,4) = 0;
		gamma_uk(10,5) = 0;
		gamma_uk(11,0) = 0;
		gamma_uk(11,1) = 0;
		gamma_uk(11,2) = 0;
		gamma_uk(11,3) = 0;
		gamma_uk(11,4) = 0;
		gamma_uk(11,5) = 0;
		gamma_uk(12,0) = 0;
		gamma_uk(12,1) = 0;
		gamma_uk(12,2) = 0;
		gamma_uk(12,3) = 0;
		gamma_uk(12,4) = 0;
		gamma_uk(12,5) = 0;
		gamma_uk(13,0) = 0;
		gamma_uk(13,1) = 0;
		gamma_uk(13,2) = 0;
		gamma_uk(13,3) = 0;
		gamma_uk(13,4) = 0;
		gamma_uk(13,5) = 0;
		gamma_uk(14,0) = 0;
		gamma_uk(14,1) = 0;
		gamma_uk(14,2) = 0;
		gamma_uk(14,3) = 0;
		gamma_uk(14,4) = 0;
		gamma_uk(14,5) = 0;
		ret_sys[1] = gamma_uk;

		// matrix which projects IMU accelerometer/gyro reading noise onto state
		Eigen::Matrix<double,15,15> gamma_wk;
		gamma_wk(0,0) = 0;
		gamma_wk(0,1) = 0;
		gamma_wk(0,2) = 0;
		gamma_wk(0,3) = -x12;
		gamma_wk(0,4) = x17;
		gamma_wk(0,5) = x19;
		gamma_wk(0,6) = 0;
		gamma_wk(0,7) = 0;
		gamma_wk(0,8) = 0;
		gamma_wk(0,9) = 0;
		gamma_wk(0,10) = 0;
		gamma_wk(0,11) = 0;
		gamma_wk(0,12) = 0;
		gamma_wk(0,13) = 0;
		gamma_wk(0,14) = 0;
		gamma_wk(1,0) = 0;
		gamma_wk(1,1) = 0;
		gamma_wk(1,2) = 0;
		gamma_wk(1,3) = x17;
		gamma_wk(1,4) = -x20;
		gamma_wk(1,5) = x22;
		gamma_wk(1,6) = 0;
		gamma_wk(1,7) = 0;
		gamma_wk(1,8) = 0;
		gamma_wk(1,9) = 0;
		gamma_wk(1,10) = 0;
		gamma_wk(1,11) = 0;
		gamma_wk(1,12) = 0;
		gamma_wk(1,13) = 0;
		gamma_wk(1,14) = 0;
		gamma_wk(2,0) = 0;
		gamma_wk(2,1) = 0;
		gamma_wk(2,2) = 0;
		gamma_wk(2,3) = x19;
		gamma_wk(2,4) = x22;
		gamma_wk(2,5) = -x27;
		gamma_wk(2,6) = 0;
		gamma_wk(2,7) = 0;
		gamma_wk(2,8) = 0;
		gamma_wk(2,9) = 0;
		gamma_wk(2,10) = 0;
		gamma_wk(2,11) = 0;
		gamma_wk(2,12) = 0;
		gamma_wk(2,13) = 0;
		gamma_wk(2,14) = 0;
		gamma_wk(3,0) = 0;
		gamma_wk(3,1) = 0;
		gamma_wk(3,2) = 0;
		gamma_wk(3,3) = x12;
		gamma_wk(3,4) = x16;
		gamma_wk(3,5) = x40;
		gamma_wk(3,6) = tan_theta*x45;
		gamma_wk(3,7) = -sin_phi*x39*x47 + x28*x46;
		gamma_wk(3,8) = x38*x45;
		gamma_wk(3,9) = 0;
		gamma_wk(3,10) = 0;
		gamma_wk(3,11) = 0;
		gamma_wk(3,12) = 0;
		gamma_wk(3,13) = 0;
		gamma_wk(3,14) = 0;
		gamma_wk(4,0) = 0;
		gamma_wk(4,1) = 0;
		gamma_wk(4,2) = 0;
		gamma_wk(4,3) = x16;
		gamma_wk(4,4) = x20;
		gamma_wk(4,5) = x57;
		gamma_wk(4,6) = -x28*x59 + x54*x60;
		gamma_wk(4,7) = x61*x63;
		gamma_wk(4,8) = x38*x44*x61;
		gamma_wk(4,9) = 0;
		gamma_wk(4,10) = 0;
		gamma_wk(4,11) = 0;
		gamma_wk(4,12) = 0;
		gamma_wk(4,13) = 0;
		gamma_wk(4,14) = 0;
		gamma_wk(5,0) = 0;
		gamma_wk(5,1) = 0;
		gamma_wk(5,2) = 0;
		gamma_wk(5,3) = x40;
		gamma_wk(5,4) = x57;
		gamma_wk(5,5) = x27;
		gamma_wk(5,6) = -tan_theta*x72 + x31*x59;
		gamma_wk(5,7) = -x46*x71 + x47*x70;
		gamma_wk(5,8) = x38*(tan_theta*x31*x44 - x72);
		gamma_wk(5,9) = 0;
		gamma_wk(5,10) = 0;
		gamma_wk(5,11) = 0;
		gamma_wk(5,12) = 0;
		gamma_wk(5,13) = 0;
		gamma_wk(5,14) = 0;
		gamma_wk(6,0) = 0;
		gamma_wk(6,1) = 0;
		gamma_wk(6,2) = 0;
		gamma_wk(6,3) = 0;
		gamma_wk(6,4) = 0;
		gamma_wk(6,5) = 0;
		gamma_wk(6,6) = x59*x88 - x78*x87;
		gamma_wk(6,7) = -x78*x89 + x86*x88;
		gamma_wk(6,8) = x38*(tan_theta*x44*x88 - x78*x90);
		gamma_wk(6,9) = 0;
		gamma_wk(6,10) = 0;
		gamma_wk(6,11) = 0;
		gamma_wk(6,12) = x91;
		gamma_wk(6,13) = tan_theta*x93;
		gamma_wk(6,14) = tan_theta*x95;
		gamma_wk(7,0) = 0;
		gamma_wk(7,1) = 0;
		gamma_wk(7,2) = 0;
		gamma_wk(7,3) = 0;
		gamma_wk(7,4) = 0;
		gamma_wk(7,5) = 0;
		gamma_wk(7,6) = tan_theta*x100 - tan_theta*x101 + x59*x79;
		gamma_wk(7,7) = x46 + x87;
		gamma_wk(7,8) = x38*(x100 - x101 + x60*x79);
		gamma_wk(7,9) = 0;
		gamma_wk(7,10) = 0;
		gamma_wk(7,11) = 0;
		gamma_wk(7,12) = 0;
		gamma_wk(7,13) = cos_phi*x92;
		gamma_wk(7,14) = -sin_phi*x94;
		gamma_wk(8,0) = 0;
		gamma_wk(8,1) = 0;
		gamma_wk(8,2) = 0;
		gamma_wk(8,3) = 0;
		gamma_wk(8,4) = 0;
		gamma_wk(8,5) = 0;
		gamma_wk(8,6) = x38*(tan_theta*x42 + tan_theta*x43 - x58*x90 - x59*x75);
		gamma_wk(8,7) = x38*(cos_phi*sig_gy*sin_phi - tan_theta*x89 - x101 - x75*x86);
		gamma_wk(8,8) = x78*(x44 - x60*x75 - x87);
		gamma_wk(8,9) = 0;
		gamma_wk(8,10) = 0;
		gamma_wk(8,11) = 0;
		gamma_wk(8,12) = 0;
		gamma_wk(8,13) = x38*x93;
		gamma_wk(8,14) = x38*x95;
		gamma_wk(9,0) = 0;
		gamma_wk(9,1) = 0;
		gamma_wk(9,2) = 0;
		gamma_wk(9,3) = 0;
		gamma_wk(9,4) = 0;
		gamma_wk(9,5) = 0;
		gamma_wk(9,6) = 0;
		gamma_wk(9,7) = 0;
		gamma_wk(9,8) = 0;
		gamma_wk(9,9) = 0;
		gamma_wk(9,10) = 0;
		gamma_wk(9,11) = 0;
		gamma_wk(9,12) = 0;
		gamma_wk(9,13) = 0;
		gamma_wk(9,14) = 0;
		gamma_wk(10,0) = 0;
		gamma_wk(10,1) = 0;
		gamma_wk(10,2) = 0;
		gamma_wk(10,3) = 0;
		gamma_wk(10,4) = 0;
		gamma_wk(10,5) = 0;
		gamma_wk(10,6) = 0;
		gamma_wk(10,7) = 0;
		gamma_wk(10,8) = 0;
		gamma_wk(10,9) = 0;
		gamma_wk(10,10) = 0;
		gamma_wk(10,11) = 0;
		gamma_wk(10,12) = 0;
		gamma_wk(10,13) = 0;
		gamma_wk(10,14) = 0;
		gamma_wk(11,0) = 0;
		gamma_wk(11,1) = 0;
		gamma_wk(11,2) = 0;
		gamma_wk(11,3) = 0;
		gamma_wk(11,4) = 0;
		gamma_wk(11,5) = 0;
		gamma_wk(11,6) = 0;
		gamma_wk(11,7) = 0;
		gamma_wk(11,8) = 0;
		gamma_wk(11,9) = 0;
		gamma_wk(11,10) = 0;
		gamma_wk(11,11) = 0;
		gamma_wk(11,12) = 0;
		gamma_wk(11,13) = 0;
		gamma_wk(11,14) = 0;
		gamma_wk(12,0) = 0;
		gamma_wk(12,1) = 0;
		gamma_wk(12,2) = 0;
		gamma_wk(12,3) = 0;
		gamma_wk(12,4) = 0;
		gamma_wk(12,5) = 0;
		gamma_wk(12,6) = 0;
		gamma_wk(12,7) = 0;
		gamma_wk(12,8) = 0;
		gamma_wk(12,9) = 0;
		gamma_wk(12,10) = 0;
		gamma_wk(12,11) = 0;
		gamma_wk(12,12) = x91*(x104 + 1);
		gamma_wk(12,13) = 0;
		gamma_wk(12,14) = 0;
		gamma_wk(13,0) = 0;
		gamma_wk(13,1) = 0;
		gamma_wk(13,2) = 0;
		gamma_wk(13,3) = 0;
		gamma_wk(13,4) = 0;
		gamma_wk(13,5) = 0;
		gamma_wk(13,6) = 0;
		gamma_wk(13,7) = 0;
		gamma_wk(13,8) = 0;
		gamma_wk(13,9) = 0;
		gamma_wk(13,10) = 0;
		gamma_wk(13,11) = 0;
		gamma_wk(13,12) = 0;
		gamma_wk(13,13) = x92*(x105 + 1);
		gamma_wk(13,14) = 0;
		gamma_wk(14,0) = 0;
		gamma_wk(14,1) = 0;
		gamma_wk(14,2) = 0;
		gamma_wk(14,3) = 0;
		gamma_wk(14,4) = 0;
		gamma_wk(14,5) = 0;
		gamma_wk(14,6) = 0;
		gamma_wk(14,7) = 0;
		gamma_wk(14,8) = 0;
		gamma_wk(14,9) = 0;
		gamma_wk(14,10) = 0;
		gamma_wk(14,11) = 0;
		gamma_wk(14,12) = 0;
		gamma_wk(14,13) = 0;
		gamma_wk(14,14) = x94*(x106 + 1);
		ret_sys[2] = gamma_wk;


		return ret_sys;
	}

    void update_nominal_state(ImuStateVector& nominal_state, ImuData& imu_measurements) {
        // hard code for now 
        // make this a memory map auto generation from the python hpp generator
        // we'll define the state vector as:
        // [r, v, E, b_a, b_g]
        // r -> position 
        // v -> velocity
        // E -> attitude
        // b_a -> moving IMU accelerometer bias
        // b_e -> moving IMU gyro bias

        // update attitude
        phi = nominal_state.phi;
        theta = nominal_state.theta;
        psi = nominal_state.psi;

        // the IMU measurements will be ingested as the linearization points for the attitude interpretation
        fbx = imu_measurements.accx;
        fby = imu_measurements.accy;
        fbz = imu_measurements.accz;

        psi_dot = imu_measurements.dpsiz;
        theta_dot = imu_measurements.dthetay;
    }

    void accept_configs(Config system_configs) {
        // open loaded configurations and assign member variables
        // accelerometer white noise
        sig_ax = system_configs.sig_ax;
        sig_ay = system_configs.sig_ay;
        sig_az = system_configs.sig_az;

        // gyro white noise
        sig_gx = system_configs.sig_gx;
        sig_gy = system_configs.sig_gy;
        sig_gz = system_configs.sig_gz;

        // FOGMP accelerometer white noise
        sig_tax = system_configs.sig_tax;
        sig_tay = system_configs.sig_tay;
        sig_taz = system_configs.sig_taz;

        // FOGMP gyro white noise
        sig_tgx = system_configs.sig_tgx;
        sig_tgy = system_configs.sig_tgy;
        sig_tgz = system_configs.sig_tgz;

        // time constants for FOGMPs
        tau_gx = system_configs.tau_gx;
        tau_gy = system_configs.tau_gy;
        tau_gz = system_configs.tau_gz;

        tau_ax = system_configs.tau_ax;
        tau_ay = system_configs.tau_ay;
        tau_az = system_configs.tau_az;

        // set system update time
        Ts = system_configs.Ts;

        std::cout << "State space models are configured" << std::endl;
    }

private:
	// Member symbols
	double Ts;
	double fbx;
	double fby;
	double fbz;
	double phi;
	double psi;
	double psi_dot;
	double sig_ax;
	double sig_ay;
	double sig_az;
	double sig_gx;
	double sig_gy;
	double sig_gz;
	double sig_tax;
	double sig_tay;
	double sig_taz;
	double sig_tgx;
	double sig_tgy;
	double sig_tgz;
	double tau_ax;
	double tau_ay;
	double tau_az;
	double tau_gx;
	double tau_gy;
	double tau_gz;
	double theta;
	double theta_dot;

};

#endif // GENERATED_MATRICES_HPP
