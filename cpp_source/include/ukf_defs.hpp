// Auto-generated by ukf_codegen.py
#pragma once

#include <Eigen/Dense>
#include <array>

constexpr int N = 15;
constexpr int M = 6;
constexpr int Z = 6;
constexpr int NumSigma = 2 * N + 1;

using StateVec = Eigen::Matrix<double, N, 1>;
using InputVec = Eigen::Matrix<double, M, 1>;
using CovMat   = Eigen::Matrix<double, N, N>;
using MeasVec  = Eigen::Matrix<double, Z, 1>;
using MeasCov  = Eigen::Matrix<double, Z, Z>;
using ControlInput  = Eigen::Matrix<double, M, 1>;
using SigmaPointArray = std::array<StateVec, NumSigma>;

struct Observable {
    double timestamp;
    MeasVec observation;
    MeasCov R;
};

struct UKFParams {
    double tau_a, tau_g;       // time constants for gyro/accel FOGMP
    double sig_a, sig_g;       // variance on AWGN on FOGMP process
    double gx, gy, gz;         // gravity config
};

inline StateVec f_cont(
    const StateVec& x,
    const InputVec& u,
    double tau_a, double tau_g,
    double gx, double gy, double gz) {

    StateVec dx;

    // Trig shorthands
    double phi = x(6), theta = x(7), psi = x(8);
    double sin_phi = sin(phi);
    double cos_phi = cos(phi);
    double sin_theta = sin(theta);
    double cos_theta = cos(theta);
    double tan_theta = tan(theta);
    double sec_theta = 1.0 / cos_theta;
    double sin_psi = sin(psi);
    double cos_psi = cos(psi);

    // common subexpressions
    double x0 = u(3) - x(9);
    double x1 = cos_theta*x(0);
    double x2 = u(5) - x(11);
    double x6 = sin_phi*sin_psi;
    double x7 = cos_phi*cos_psi;
    double x8 = u(4) - x(10);
    double x15 = cos_phi*sin_psi;
    double x16 = u(2) - x(14);
    double x17 = cos_phi*x(16);
    double x18 = u(1) - x(13);
    double x19 = sin_phi*x(18);
    double x20 = 1/tau_a;
    double x21 = 1/tau_g;

    // state derivatives
    dx(0) = x(3);
    dx(1) = x(4);
    dx(2) = x(5);
    dx(3) = cos_psi*x(1) - gx + x(2)*(sin_theta*x(7) + x(6)) + x(8)*(cos_psi*sin_phi*sin_theta - x(15));
    dx(4) = -gy + sin_psi*x(1) + x(2)*(-cos_psi*sin_phi + sin_theta*x(15)) + x(8)*(sin_theta*x(6) + x(7));
    dx(5) = cos_phi*cos_theta*x(2) + cos_theta*sin_phi*x(8) - gz - sin_theta*x(0);
    dx(6) = tan_theta*x(17) + tan_theta*x(19) + u(0) - x(12);
    dx(7) = cos_phi*x(18) - sin_phi*x(16);
    dx(8) = sec_theta*x(17) + sec_theta*x(19);
    dx(9) = -x(20)*x(9);
    dx(10) = -x(10)*x(20);
    dx(11) = -x(11)*x(20);
    dx(12) = -x(12)*x(21);
    dx(13) = -x(13)*x(21);
    dx(14) = -x(14)*x(21);

    return dx;
}

inline StateVec rk4_step(const StateVec& x, const ControlInput& u, double dt, const UKFParams& params) {
    StateVec k1 = f_cont(x, u, params.tau_a, params.tau_g, params.gx, params.gy, params.gz);
    StateVec k2 = f_cont(x + 0.5 * dt * k1, u, params.tau_a, params.tau_g, params.gx, params.gy, params.gz);
    StateVec k3 = f_cont(x + 0.5 * dt * k2, u, params.tau_a, params.tau_g, params.gx, params.gy, params.gz);
    StateVec k4 = f_cont(x + dt * k3, u, params.tau_a, params.tau_g, params.gx, params.gy, params.gz);
    return x + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
}
