import re
from io import TextIOWrapper
from typing import Callable

import sympy as sp
import ukf_model as ukf


def convert_expr_to_eigen(expr_str: str) -> str:
    # Replace u0, u1, ..., u5 with u(0), u(1), ...
    expr_str = re.sub(r'\bu(\d+)\b', r'u(\1)', expr_str)
    # Replace x0, x1, ..., x14 with x(0), x(1), ...
    expr_str = re.sub(r'\bx(\d+)\b', r'x(\1)', expr_str)
    return expr_str


def emit_f_cont_to_cpp(f_cont: Callable[..., sp.Matrix], params: dict, file: TextIOWrapper, state_size=15, input_size=6):
    # define symbolic state and input
    x = sp.Matrix(sp.symbols(f'x0:{state_size}'))
    u = sp.Matrix(sp.symbols(f'u0:{input_size}'))

    # "codegen" mode will get symbolic matrices
    dx = f_cont(x, u, params, codegen_mode=True)

    # sympy won't optimze sin(x) unless we make a variable "sin_x"
    phi, theta, psi = x[6], x[7], x[8]
    trig_subs = {
        sp.sin(phi): sp.Symbol("sin_phi"),
        sp.cos(phi): sp.Symbol("cos_phi"),
        sp.sin(theta): sp.Symbol("sin_theta"),
        sp.cos(theta): sp.Symbol("cos_theta"),
        sp.tan(theta): sp.Symbol("tan_theta"),
        1/sp.cos(theta): sp.Symbol("sec_theta"),
        sp.sin(psi): sp.Symbol("sin_psi"),
        sp.cos(psi): sp.Symbol("cos_psi"),
    }

    dx = dx.subs(trig_subs)

    # apply common subexpression elimination
    replacements, reduced = sp.cse(dx)

    # --- begin header file output ---
    file.write("// Auto-generated by ukf_codegen.py\n")
    file.write("#pragma once\n\n")
    file.write("#include <Eigen/Dense>\n")
    file.write("#include <array>\n\n")

    # constants and types
    file.write(f"constexpr int N = {state_size};\n")
    file.write(f"constexpr int M = {input_size};\n")
    file.write("constexpr int NumSigma = 2 * N + 1;\n\n")

    file.write("using StateVec = Eigen::Matrix<double, N, 1>;\n")
    file.write("using InputVec = Eigen::Matrix<double, M, 1>;\n")
    file.write("using CovMat   = Eigen::Matrix<double, N, N>;\n")
    file.write("using MeasVec  = Eigen::Matrix<double, M, 1>;\n")
    file.write("using SigmaPointArray = std::array<StateVec, NumSigma>;\n\n")

    # Parameter struct
    file.write("struct UKFParams {\n")
    file.write("    double tau_a, tau_g;\n")
    file.write("    double gx, gy, gz;\n")
    file.write("};\n\n")

    file.write("inline StateVec f_cont(\n")
    file.write("    const StateVec& x,\n")
    file.write("    const InputVec& u,\n")
    file.write("    double tau_a, double tau_g,\n")
    file.write("    double gx, double gy, double gz) {\n\n")

    file.write("    StateVec dx;\n\n")

    # trig shorthands
    file.write("    // Trig shorthands\n")
    file.write("    double phi = x(6), theta = x(7), psi = x(8);\n")
    file.write("    double sin_phi = sin(phi);\n")
    file.write("    double cos_phi = cos(phi);\n")
    file.write("    double sin_theta = sin(theta);\n")
    file.write("    double cos_theta = cos(theta);\n")
    file.write("    double tan_theta = tan(theta);\n")
    file.write("    double sec_theta = 1.0 / cos_theta;\n")
    file.write("    double sin_psi = sin(psi);\n")
    file.write("    double cos_psi = cos(psi);\n\n")

    # CSE intermediate expressions
    file.write("    // common subexpressions\n")
    for sym, expr in replacements:
        expr_cpp = convert_expr_to_eigen(str(expr))
        file.write(f"    double {sym} = {expr_cpp};\n")
    file.write("\n")

    # state derivative assignments
    file.write("    // state derivatives\n")
    for i, expr in enumerate(reduced[0]):
        expr_cpp = convert_expr_to_eigen(str(expr))
        file.write(f"    dx({i}) = {expr_cpp};\n")

    file.write("\n    return dx;\n")
    file.write("}\n")


def main() -> None:
    # define symbolic parameters
    params = {
        'tau_a': sp.Symbol('tau_a'),
        'tau_g': sp.Symbol('tau_g'),
        'g_n': sp.Matrix([sp.Symbol('gx'), sp.Symbol('gy'), sp.Symbol('gz')])
    }

    # Write out dynamics
    full_file_path = "generated_f_cont.hpp"
    with open(full_file_path, 'w') as file:
        emit_f_cont_to_cpp(ukf.f_cont, params, file)

if __name__ == "__main__":
    main()