import os
from typing import Dict, List, Set, Tuple

import sympy as sp
from sympy import ccode

def export_matrices_to_hpp(
    matrices_list: List[Dict[str, Tuple[sp.Matrix, str]]],
    filename: str = "GeneratedMatrices.hpp"
) -> None:
    """
    Export symbolic matrices to a C++ header file using Eigen syntax, with common sub-expressions
    like sin, cos, and tan manually extracted and precomputed at the top of each function.

    Parameters:
        matrices (dict): Dictionary of matrices with labels as keys and SymPy matrices as values.
        filename (str): Name of the output header file.
    """
    # remove old file if present
    full_file_path = os.path.join("cpp_source", "include", filename)
    if os.path.exists(full_file_path):
        try:
            os.remove(full_file_path)
        except Exception as e:
            print(f"Could not delete old generated hpp: {e}")

    # collect all free symbols from the matrices -- these'll be class members in the hpp
    symbols: Set[sp.Symbol] = set()
    for matrices in matrices_list:
        for matrix, _ in matrices.values():
            symbols.update(matrix.free_symbols)

    # flatten matrices and track column offsets so we can slice these out later
    flat: List[Tuple[str, sp.Matrix, str]] = []
    offsets: List[int] = []
    col_offset = 0
    for block in matrices_list:
        for label, (M, comment) in block.items():
            flat.append((label, M, comment))
            offsets.append(col_offset)
            col_offset += M.shape[1]

    # sympy won't optimze sin(x) unless we make a variable "sin_x"
    theta, phi = sp.symbols('theta phi')
    trig_subs = {
        sp.sin(theta): sp.Symbol('sin_theta'),
        sp.cos(theta): sp.Symbol('cos_theta'),
        sp.tan(theta): sp.Symbol('tan_theta'),
        sp.sin(phi):   sp.Symbol('sin_phi'),
        sp.cos(phi):   sp.Symbol('cos_phi'),
    }

    # write into header file
    with open(full_file_path, 'w') as file:
        file.write("// Auto-generated by export_matrices_to_hpp.py\n")
        file.write("#ifndef GENERATED_MATRICES_HPP\n")
        file.write("#define GENERATED_MATRICES_HPP\n\n")
        file.write("#include <array>\n")
        file.write("#include <iostream>\n")
        file.write("#include <Eigen/Dense>\n\n")

        # Prepend structs and definitions
        file.write("// struct for setting up IMU dynamics based on an external file read\n")
        file.write("struct Config {\n")
        file.write("    double sig_ax, sig_ay, sig_az; // accel variances\n")
        file.write("    double sig_gx, sig_gy, sig_gz; // gyro variances\n")
        file.write("    double sig_tax, sig_tay, sig_taz; // accel FOGMP noise\n")
        file.write("    double sig_tgx, sig_tgy, sig_tgz; // gyro FOGMP noise\n")
        file.write("    double tau_gx, tau_gy, tau_gz; // gyro bias time constants\n")
        file.write("    double tau_ax, tau_ay, tau_az; // accel bias time constants\n")
        file.write("    double Ts; // update interval\n")
        file.write("};\n\n")

        file.write("// measurements and expected state vector definitions\n")
        file.write("struct ImuData {\n")
        file.write("    double accx, accy, accz;\n")
        file.write("    double dphix, dthetay, dpsiz;\n")
        file.write("    double measurement_time;\n")
        file.write("    Eigen::Matrix<double,6,1> matrix_form_measurement;\n\n")
        file.write("    void updateFromMatrix() {\n")
        file.write("        accx    = matrix_form_measurement(0); accy    = matrix_form_measurement(1); accz    = matrix_form_measurement(2);\n")
        file.write("        dphix   = matrix_form_measurement(3); dthetay = matrix_form_measurement(4); dpsiz   = matrix_form_measurement(5);\n")
        file.write("    }\n\n")
        file.write("    void updateFromDoubles() {\n")
        file.write("        matrix_form_measurement(0)=accx; matrix_form_measurement(1)=accy; matrix_form_measurement(2)=accz;\n")
        file.write("        matrix_form_measurement(3)=dphix; matrix_form_measurement(4)=dthetay; matrix_form_measurement(5)=dpsiz;\n")
        file.write("    }\n")
        file.write("};\n\n")

        file.write("struct ImuStateVector {\n")
        file.write("    double pos_x,pos_y,pos_z; double vel_x,vel_y,vel_z;\n")
        file.write("    double phi,theta,psi; double bias_x,bias_y,bias_z;\n")
        file.write("    double bias_phi,bias_theta,bias_psi;\n")
        file.write("    double solution_time;\n")
        file.write("    Eigen::Matrix<double,15,1> matrix_form_states;\n\n")
        file.write("    void updateFromMatrix() {\n")
        file.write("        pos_x=matrix_form_states(0); pos_y=matrix_form_states(1); pos_z=matrix_form_states(2);\n")
        file.write("        vel_x=matrix_form_states(3); vel_y=matrix_form_states(4); vel_z=matrix_form_states(5);\n")
        file.write("        phi  =matrix_form_states(6); theta=matrix_form_states(7); psi  =matrix_form_states(8);\n")
        file.write("        bias_x=matrix_form_states(9); bias_y=matrix_form_states(10); bias_z=matrix_form_states(11);\n")
        file.write("        bias_phi=matrix_form_states(12); bias_theta=matrix_form_states(13); bias_psi=matrix_form_states(14);\n")
        file.write("    }\n")
        file.write("};\n\n")

        file.write("struct ImuCovariance {\n")
        file.write("    double solution_time;\n")
        file.write("    Eigen::Matrix<double,15,15> covariance_matrix;\n")
        file.write("};\n\n")

        # Begin class
        file.write("class GeneratedMatrices {\npublic:\n")

        # Combine all matrices for global CSE
        combined = sp.Matrix.hstack(*[M for _, M, _ in flat])
        combined_sub = combined.subs(trig_subs)
        replacements, reduced_list = sp.cse([combined_sub], optimizations='basic')
        reduced = reduced_list[0]

        #  write in system generator
        file.write(f"\tstd::array<Eigen::MatrixXd,{len(matrices_list)}> eval_generated_system() {{\n")
        # allocate a return value
        file.write(f"\t\tstd::array<Eigen::MatrixXd,{len(matrices_list)}> ret_sys;\n\n")

        # Trig shorthands inside function
        file.write("\t\t// Trig shorthands\n")
        for expr, sym in trig_subs.items():
            file.write(f"\t\tdouble {sym} = {ccode(expr)};\n")
        file.write("\n")

        # CSE temporaries inside function
        file.write("\t\t// common sub-expression from sympy\n")
        for idx, (tmp, expr) in enumerate(replacements):
            file.write(f"\t\tdouble {tmp} = {ccode(expr)};\n")
        file.write("\n")

        # write in matrices
        acc: int = 0
        for (label, M, comment), base_col in zip(flat, offsets):
            r, c = M.shape
            if comment:
                file.write(f"\t\t// {comment}\n")
            file.write(f"\t\tEigen::Matrix<double,{r},{c}> {label};\n")

            # Populate matrix slice
            for i in range(r):
                for j in range(c):
                    expr = reduced[i, base_col + j]
                    file.write(f"\t\t{label}({i},{j}) = {ccode(expr)};\n")
            file.write(f"\t\tret_sys[{acc}] = {label};\n\n")

        # add to return system  
        file.write("\n\t\treturn ret_sys;\n\t}\n\n")

        # Additional public helper methods
        file.write("    void update_nominal_state(ImuStateVector& nominal_state, ImuData& imu_measurements) {\n")
        file.write("        // hard code for now \n")
        file.write("        // make this a memory map auto generation from the python hpp generator\n")
        file.write("        // we'll define the state vector as:\n")
        file.write("        // [r, v, E, b_a, b_g]\n")
        file.write("        // r -> position \n")
        file.write("        // v -> velocity\n")
        file.write("        // E -> attitude\n")
        file.write("        // b_a -> moving IMU accelerometer bias\n")
        file.write("        // b_e -> moving IMU gyro bias\n\n")
        file.write("        // update attitude\n")
        file.write("        phi = nominal_state.phi;\n")
        file.write("        theta = nominal_state.theta;\n")
        file.write("        psi = nominal_state.psi;\n\n")
        file.write("        // the IMU measurements will be ingested as the linearization points for the attitude interpretation\n")
        file.write("        fbx = imu_measurements.accx;\n")
        file.write("        fby = imu_measurements.accy;\n")
        file.write("        fbz = imu_measurements.accz;\n\n")
        file.write("        psi_dot = imu_measurements.dpsiz;\n")
        file.write("        theta_dot = imu_measurements.dthetay;\n")
        file.write("    }\n\n")
        file.write("    void accept_configs(Config system_configs) {\n")
        file.write("        // open loaded configurations and assign member variables\n")
        file.write("        // accelerometer white noise\n")
        file.write("        sig_ax = system_configs.sig_ax;\n")
        file.write("        sig_ay = system_configs.sig_ay;\n")
        file.write("        sig_az = system_configs.sig_az;\n\n")
        file.write("        // gyro white noise\n")
        file.write("        sig_gx = system_configs.sig_gx;\n")
        file.write("        sig_gy = system_configs.sig_gy;\n")
        file.write("        sig_gz = system_configs.sig_gz;\n\n")
        file.write("        // FOGMP accelerometer white noise\n")
        file.write("        sig_tax = system_configs.sig_tax;\n")
        file.write("        sig_tay = system_configs.sig_tay;\n")
        file.write("        sig_taz = system_configs.sig_taz;\n\n")
        file.write("        // FOGMP gyro white noise\n")
        file.write("        sig_tgx = system_configs.sig_tgx;\n")
        file.write("        sig_tgy = system_configs.sig_tgy;\n")
        file.write("        sig_tgz = system_configs.sig_tgz;\n\n")
        file.write("        // time constants for FOGMPs\n")
        file.write("        tau_gx = system_configs.tau_gx;\n")
        file.write("        tau_gy = system_configs.tau_gy;\n")
        file.write("        tau_gz = system_configs.tau_gz;\n\n")
        file.write("        tau_ax = system_configs.tau_ax;\n")
        file.write("        tau_ay = system_configs.tau_ay;\n")
        file.write("        tau_az = system_configs.tau_az;\n\n")
        file.write("        // set system update time\n")
        file.write("        Ts = system_configs.Ts;\n\n")
        file.write("        std::cout << \"State space models are configured\" << std::endl;\n")
        file.write("    }\n\n")

        # write in common members in private variables
        file.write("private:\n")

        # Symbol member declarations
        file.write("\t// Member symbols\n")
        for sym in sorted(symbols, key=lambda s: s.name):
            file.write(f"\tdouble {sym};\n")
        file.write("\n")

        file.write("};\n\n")
        file.write("#endif // GENERATED_MATRICES_HPP\n")
