import os
from typing import Dict, List, Set, Tuple

import sympy as sp
from sympy import ccode


def export_matrices_to_hpp(matrices_list: List[Dict[str, Tuple[sp.Matrix, str]]], filename: str="GeneratedMatrices.hpp") -> None:
    """
    Export symbolic matrices to a C++ header file using Eigen syntax, with common sub-expressions
    like sin, cos, and tan manually extracted and precomputed at the top of each function.

    Parameters:
        matrices (dict): Dictionary of matrices with labels as keys and SymPy matrices as values.
        filename (str): Name of the output header file.
    """
    # remove old file (if present)
    full_file_path = os.path.join("cpp_source", "include", filename)
    if os.path.exists(full_file_path):
        try:
            os.remove(full_file_path)
        except Exception as e:
            print(f"Got an exception trying to delete old generated hpp: {e}")

    # get all free symbols for member variables
    for matrices in matrices_list:
        # Collect all unique symbols in the matrices
        symbols: Set[sp.symbols] = set()
        for matrix, _ in matrices.values():
            symbols.update(matrix.free_symbols)
        
    # write in header info
    with open(full_file_path, "a") as file:
        file.write("// This file is automatically generated by 'write_to_hpp.py'.\n")
        file.write("#ifndef GENERATED_MATRICES_HPP\n#define GENERATED_MATRICES_HPP\n\n")
        file.write("#include <Eigen/Dense>\n\n")
        file.write("class GeneratedMatrices {\npublic:\n")

        # Declare member variables for each symbol
        file.write("\t// Member variables for symbols\n")
        for symbol in sorted(symbols, key=lambda s: s.name):  # Sort by symbol name for readability
            file.write(f"\tdouble {symbol};\n")
        file.write("\n")
        
        # define the literals that contain the trig subs
        trig_subs_literals: str = ""

        # Manually substitute common trigonometric expressions -- sympy doesn't optimize sin(x), just x
        trig_subs = {
            sp.sin(sp.Symbol('theta')): sp.Symbol('sin_theta'),
            sp.cos(sp.Symbol('theta')): sp.Symbol('cos_theta'),
            sp.tan(sp.Symbol('theta')): sp.Symbol('tan_theta'),
            sp.sin(sp.Symbol('phi')): sp.Symbol('sin_phi'),
            sp.cos(sp.Symbol('phi')): sp.Symbol('cos_phi')
        }  

        # Declare variables for manually substituted trigonometric expressions
        for trig_expr, symbol in trig_subs.items():
            trig_subs_literals += f"\t\tdouble {symbol} = {ccode(trig_expr)};\n"
        trig_subs_literals += "\n"

        file.write("Shorthands for trig functions so that we aren't constantly evaluating them\n")
        file.write(trig_subs_literals)

        # pull out the matrices
        matrices: List[sp.Matrix] = [matrix for d in matrices_list for matrix, _ in d.values()]
        tmp_combined_matrix: sp.Matrix = sp.Matrix(sp.Matrix.hstack(*matrices))

        # put in the new symbols so that sympy tries to optimize
        tmp_combined_matrix_subbed = tmp_combined_matrix.subs(trig_subs) # this was for [sin(x), cos(y)] -> [sin_x, cos_y] put in our 'new symbols'

        # call the cse functions
            # Extract common sub-expressions after substitution
        common_symbols_literals: str = ""
        replacements, reduced_matrix = sp.cse([tmp_combined_matrix_subbed], optimizations='basic')
        
        # Extract common sub-expressions after substitution
        reduced_matrix = reduced_matrix[0]

        # Declare variables for other common sub-expressions found by cse
        for i, (_, replacement) in enumerate(replacements):
            common_symbols_literals += f"\t\tdouble x{i} = {ccode(replacement)};\n"
        common_symbols_literals += "\n"           

        # Generate a function for each matrix, now that we have all these fancy terms
        for matrices in matrices_list:  
            for label, (matrix, comment) in matrices.items():
                if comment:
                    file.write(f"\t// {comment}\n")

                # Convert matrix to C++ code with Eigen syntax
                rows, cols = matrix.shape
                matrix_code = f"\tEigen::Matrix<double, {rows}, {cols}> eval_{label}()  {{\n"
                matrix_code += f"\t\tEigen::Matrix<double, {rows}, {cols}> mat;\n\n"
                
                # TODO - slice out the optimized matrices from the optimzed hstack, reduced_matrix 
                # slides_matrix: sp.Matrix = some slicing garbage that'll be wrong over and over
                # shift the matrix after, or add counters to move over the next slice

                # Populate each element in the matrix using the reduced matrix
                for i in range(rows):
                    for j in range(cols):
                        cpp_expr = ccode(reduced_matrix[i, j]).replace("t", "t")  # TODO - need to replce with slice from matrix
                        matrix_code += f"        mat({i}, {j}) = {cpp_expr};\n"
                
                matrix_code += "\t\treturn mat;\n    }\n\n"
                file.write(matrix_code)

        # Close the class and header guards
        file.write("};\n\n")
        file.write("#endif // GENERATED_MATRICES_HPP\n")